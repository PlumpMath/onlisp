;21. 여러 프로세스
;이전 장에서 실행 프로그램 자체의 상태를 잡아 프로그램을 실행시키도록 허용하는 continuations를 어떻게 허용하는지 보여줬다. 그리고 나중에 다시 시작하기 위하여 그것을 멀리 저장할 수있는 방법을 보여주었다. 이 장에서는 단일 프로그램은 아니지만 독립된 프로세스의 집합인 계산 모델을 다룬다. 프로세스의 개념은 프로그램의 상태에 대한 우리의 개념과 긴밀하게 대응한다. 이전 장에서 그 위에 매크로의 추가 계층을 작성함으로써, 우리는 Common LISP 프로그램에서 멀티프로세싱을 내장할 수 있다.

;21.1 프로세스 추상화
;여러 프로세스가 한 번에 여러 가지 일을해야 프로그램을 표현하는 편리한 방법입니다. 기존의 프로세서는 한 번에 하나의 명령을 실행합니다. 여러 프로세스가 한 번에 하나 이상의 일을 할 것이라고 말하는 건 그들이 아무 래도 하드웨어 한계를 극복한다는 말을하지 않는 것입니다 : 무엇을 의미하는 것은 그들이 우리가 추상화의 새로운 차원에서 생각하고있게하는,있는 우리는 지정하지 않아도 컴퓨터가 주어진 시간에 정확하게하고있다. 가상 메모리는 컴퓨터가 컴퓨터가 한 번에 하나 이상의 프로그램을 실행할 수있는 것처럼 실제로, 프로세스의 개념은 우리가 행동을 허용 않는 것보다 더 많은 메모리를 가지고 것처럼 우리가 행동할 수있는 것처럼.

;과정의 연구는 운영 체제의 도메인에 전통적으로있다. 그러나 추상화와 같은 프로세스의 유용은 운영 체제에 국한되지 않습니다. 그들은 똑같이 다른 실시간 어플 리케이션에 유용하고, 시뮬레이션에 있습니다.

;여러 프로세스에서 수행 작업의 대부분 문제가 특정 유형의 회피하는데 최선을 다해오고 있습니다. 이 프로세스가 각각 다른 전에 문턱을 건너 거부 이명처럼 뭔가를하고 다른이를 기다 리오 모두 스탠드 : 교착 상태는 여러 프로세스가 하나의 고전적인 문제입니다. 또 다른 문제는 일관성없는 상태로 시스템을 잡는다 쿼리입니다 - 시스템이 한 계정에서 다른 자금을 전송하는 동안 수신 잔액 조회는 말한다. 여기에 제시된 코드는 교착 상태 또는 일관성없는 상태를 예방을위한 알고리즘을 테스트하기 위해 사용될 수 있지만 그 자체가 이러한 문제에 대해 어떠한 보호 기능을 제공하지 않습니다;이 장에서는 프로세스 추상화 자체에 대해서만 다룹니다.

;가능한 한 작은로서 LISP 방해 :이 장에서 구현은 이 책에있는 모든 프로그램의 암묵적 규칙을 따릅니다. 정신력으로 프로그램이 오히려 작성된 별도의 응용 프로그램보다 언어의 수정처럼 가능한 한 일이 틀림없다. LISP 누구의 부품을 잘 맞는것 기계처럼, 그들은 더욱 강력하게 함께 프로그램이 조화 만들기. 그것은 또한 노력을 절약, 가끔은 LISP 당신을 위해 당신의 놀라운 양을 할 수 있습니다.

;이 장의 목적은 여러 프로세스를 지원하는 언어를 만드는 것입니다. 우리의 전략은 몇 가지 새로운 연산자를 추가하여 같은 언어로 LISP를 설정하는 것입니다. 우리 언어의 기본 요소는 다음과 같이됩니다 : 함수는 이전 챕터에서 =defun 또는 =lambda 매크로로 정의됩니다. 프로세스는 함수 호출에서 인스턴스됩니다. 활성 프로세스의 수, 또는 어느 한 함수에서 프로세스 인스턴스의 수에는 제한이 없습니다. 각 과정은 처음에는 그것이 생성된 인자로 주어진 우선 순위를해야합니다. 잠깐 식은 함수 내에서 발생할 수 있습니다. 대기 표현식은 변수, 테스트 표현, 및 코드의 본문을 취할 것입니다. 프로세스가 대기가 발생하면 테스트 표현식이 true를 반환 때까지 프로세스는 그 지점에서 일시 중지됩니다. 프로세스가 다시 시작되면 코드의 시체가 테스트 표현식의 값을 바인딩 변수와 함께 평가됩니다. , 또는 얼마나 자주, 그들이 평가됩니다에 대한 보장이 없기 때문에 테스트 표현은 일반적으로, 부작용이 없습니다. 예약은 우선 순위에 의해 수행됩니다. 다시 시작할 수있는 모든 프로세스, 시스템은 가장 높은 우선 순위로 하나를 실행합니다. 다른 어떤 프로세스가 가능하면 기본 프로세스가 실행됩니다. 그것은 읽기 건강 검진 보고서를 프린트 루프입니다. 대부분의 객체의 생성 및 삭제는 즉시 가능합니다. 실행중인 프로세스에서 그것은 새로운 기능을 정의할 수있을 것이고, 프로세스를 초기화하고 죽이고.

;figure 21.1 : 프로세스 구조와 인스턴스.
;Continuations가 가능한 LISP 프로그램의 상태를 저장합니다. 한 번에 여러 상태를 저장할 수있다는 것은 여러 프로세스가 발생으로부터 매우 멀리하지 않습니다. 이전 장에서 정의된 매크로는 것부터 시작해서, 우리는 여러 프로세스를 구현 미만의 코드 60 라인이 필요합니다.

;21.2 구현
;figure 21.1과 21.2는 여러 프로세스를 지원하기 위해 필요한 모든 코드를 포함합니다. 그림 21.1은 기본 데이터 구조, 기본 과정, 초기화하고, 프로세스 인스턴스에 대한 코드를 포함하고 있습니다. 프로세스, 또는 procs는 다음과 같은 구조를 가지고 :

;양수이어야 프로세스의 우선 순위입니다.
;상태는 정지 프로세스의 상태를 나타내는 연속이다. 프로세스의 상태를 funcalling으로 다시 시작됩니다.

;보통 다시 시작되는 프로세스에 대해 순서대로 TRUE를 반환하지만, 처음에는 새로 만든 프로세스의 대기는 전무입니다해야 기능입니다. NULL 대기가있는 과정은 언제나 다시 시작할 수 있습니다.
;프로그램은 세 전역 변수를 사용합니다 : * procs * 현재 중지된 프로세스 목록, * PROC * 현재 실행중인 프로세스 및 * 기본 - PROC의 * 기본 과정입니다.

;기본 과정은 다른 과정을 할 수있는 경우에만 실행됩니다. 그것은 LISP의 최상위을 시뮬레이션. 이 루프 내에서 사용자는 프로그램을 중지하거나 일시 중지 프로세스를 다시 시작하도록 유형의 표현하실 수 있습니다. 기본 프로세스가 명시적으로 건강 검진 보고서를 부르는 것을 확인할 수 있습니다. 이것은 그렇게 할 정당한되는 몇 가지 상황 중 하나입니다. 일반적으로 그것은 두 가지 이유로, 런타임에 건강 검진 보고서를 호출하기위한 좋은 생각이 아닙니다 :

;그것은 비효율과 같습니다 건강 검진 보고서는 원시 목록을 넘겨하고, 어느 자리에서 그것을 컴파일하거나 통역으로 평가해야한다. 어찌 됐든 미리 코드를 컴파일하고, 그냥 전화보다 느립니다.
;표현이없이 어휘 맥락으로 평가되기 때문에 그것은 덜 강력한입니다. 다른 것들 중에는, 이것이 표현은 평가를 받고 밖으로 보이는 일반적인 변수를 참조할 수 없다는 것을 의미합니다.
보통 건강 검진 보고서를 명시적으로 호출하는 것은 공항의 선물 가게에서 뭔가를 구입 같다. 마지막 순간까지 기다렸다가 먹고, 당신은 이류 상품의 제한된 선택을 위해 높은 가격을 지불하셔야합니다.

;앞의 두 인수 중 어느 것도 적용하면 이런 경우는 드문 경우입니다. 우리는 어쩌면 미리 표현식을 컴파 일한 없습니다. 우리는 지금 그들을 읽고, 아무 사전 없습니다. 최상위로 입력 표현식이 null이 어휘 환경에 있기 때문에 마찬가지로, 그 표현은, 어휘 변수를 둘러싼 참조 수 없습니다. 사실,이 함수의 정의는 단순히 영어 설명을 반영하는 : 그것은 어떤 사용자가 형식을 읽고 평가합니다.

;매크로 포크는 함수 호출에서 프로세스를 인스턴스. 함수는 =defun으로 평소처럼 정의됩니다 

;이제 함수 호출 및 우선 순위 번호 포크 호출할 때 :

;새로운 프로세스는 * procs가 *로 밀고있다. 새로운 프로세스가 25의 우선 순위를 가지고, 인자 2 foo에 대한 호출로 이루어진 그것은 아직 시작되지 않았기 때문에 전무의 PROC, 잠깐, 그리고 PROC 상태.

;매크로 프로그램은 우리가 프로세스 그룹을 만들고 그들을 함께 실행할 수 있습니다. 정의 :
중지 프로세스, 그리고 반복적으로 실행하는 프로세스를 선택하는 다른 코드를 지우는 코드 사이에 끼워 넣었지 두 포크 표현,로 macroexpands. 이 루프를 벗어나면, 매크로 컨트롤 프로그램을 끝낼 던져질 수있는 태그를 설정합니다. gensym로서,이 태그는 사용자의 코드에 의해 설립된 태그와 충돌하지 않습니다. 프로그램으로 정의된 프로세스 그룹에는 특정 값을 반환하지 않으며, 오직 최상위에서 호출해야 의미합니다.
;프로세스 인스턴스 후에 프로세스 스케줄링 코드는 이상 걸립니다. 이 코드는 그림 21.2에 표시됩니다. 함수 피크 프로세스가 다시 시작될 수가 가장 높은 우선 순위 프로세스를 선택하고 실행합니다. 이 과정을 선택하면 대부분의 긴급 프로세스의 작업입니다. 중지된 프로세스는 전혀 대기 기능이 없다면 실행할 수있는 자격이며, 또는 대기 함수는 true를 반환합니다. 해당 프로세스 중에서 가장 높은 우선 순위와 하나가 선택됩니다. 경력 프로세스 및 대기 기능 (하나가있는 경우)에 의해 반환된 값은 픽업 프로세스로 반환됩니다. 기본 프로세스가 항상 실행하고자하기 때문에 언제나, 어떤 경력이있는 과정이 될 것입니다.

;figure 21.2의 코드의 나머지 부분은 프로세스간에 컨트롤을 전환하는 데 사용되는 연산자를 정의합니다. 그림 21.3에있는 함수 보행자에서 사용되는 표준 대기 표현, 기다려이다. 이 예제에서는 프로세스 * 열 - 문의 * 목록에있는 무언가가있을 때까지 기다리고있다가 다음 메시지를 출력한다

;wait은 =bind의 사상과 (페이지 267) 유사하고, 마지막으로 평가될 수 있도록 다른 일을해야하는 것과 같은 제한을 운반합니다. 우리가 기다린 후 바라 는건 뭐든지은 그 본문에 넣는 방법이있다. 우리는 프로세스가 여러 번 기다려 주길 원한다면 따라서, 대기 표현은 중첩되어야합니다. 서로를 겨냥한 사실을 주장함으로써, 프로세스는 그림 21.4에서와 같이, 어떤 목표에 도달 협력하실 수 있습니다.

;figure 21.2 : 프로세스 스케줄링.

;figure 21.3 : 하나 대기가있는 하나의 과정입니다.

;방문자와 호스트 인스턴스에서 프로세스는 동일한 문을 주어진 경우, 칠판에 메시지를 통한 통제를 교환합니다

;이윤율, 그의 유일한 목적은 다른 더 높은 우선 순위 프로세스에게 실행 기회를 제공하는 것입니다 : 대기 표현의 또 다른, 단순한 유형이있다. 프로세스가 setpri 식을 실행 후 얻을하려는 수도있는 리셋 현재 프로세스의 우선순위. 수확량이의 몸 안에 넣어되어야 후 기다린과 마찬가지로 모든 코드가 실행될 수 있습니다.

;figure 21.5에있는 프로그램은 두 사업자가 함께 작동하는 방법을 보여줍니다. 처음에는 야만인 두 가지 목표가 : 로마를 캡처하여 약탈을해야합니다. 도시를 캡처하면 (약간) 더 높은 우선 순위를 가지고 있으며, 그래서 일단 실행됩니다. 도시도 줄어든다는 이후 단, 캡처 프로세스의 우선 순위는 1로 줄어 듭니다. 그렇다면 거기에 투표하고, 약탈은 가장 높은 우선 순위 프로세스로 실행되는 시작합니다.

;야만인 로마의 궁궐을 약탈하고 부호를 ransomed 후에만, 캡처 프로세스 이력서, 자신의 위치를 강화시키도록 한다.

;figure 21.4 : 칠판과 동기화.
;대기 표현 밑에는보다 일반적인 중재인이다. 이 함수는 현재 프로세스를 저장하고 다시 실행 (아마 같은) 어떤 과정을 시작 피크 프로세스 호출합니다. 테스트 기능과 연속 : 그것은 두 개의 인수를 받는다. 전직은 프로세스의 PROC, 잠깐 정지되는 형태로 저장하고, 다시 시작할 수있다면 나중에 확인하기 위해 호출됩니다. 후자 PROC 상태가, 그리고 그것이 일시 중지 프로세스를 다시 시작합니다 호출하는 것입니다.

;figure 21.5 : 변화하는 우선순위의 효력.
;매크로 람다-표현식에 그들의 시체를 배치하여 쉽게 연속 함수를 기다렸다 구축 얻을 수 있습니다. 예를 들어,

;로 확대


;코드 만들기, 그림 20.5에 나와있는 제한 사항을 따르는 경우에는 대기의 신체의 폐쇄는 전체 현재 계속 유지됩니다. =value로 은 두 번째 인수가됩니다 확장으로 # '을 (람다 (D) (funcall * cont * D)) 폐쇄가에 대한 참조가 포함되어 있기 때문에 * cont은 *이 대기 함수를 사용하여 중지 프로세스는 어디 그것에 핸들을해야합니다 그것이 정지 당시 가고되었다.

;정지 연산자는 프로그램의 확장에 의해 설립된 태그로 제어를 던지는하여 전체 프로그램을 중지합니다. 그것은 프로그램의 값으로 반환됩니다 선택적 인수를 걸립니다. 기본 프로세스가 항상 실행하고자하기 때문에, 유일한 방법은 프로그램 종료는 명시적 중단하는 것입니다. 그것은 평가되지 않기 때문에 어떤 코드는 중단을 따른다 중요하지 않습니다.

;개별 프로세스를 죽이고 호출하여 죽게 할 수 있습니다. 인수도 주어없는 경우이 연산자는 현재 프로세스를 죽이고. 이 경우, 죽이지는 현재 프로세스를 저장하는 데 무시 대기 표현 같다. 살인이 인수를 부여하는 경우, 그들은 프로세스 목록에서 삭제에 인수된다. 현재 코드에서는 많이 한 프로세스가 참조하는 여러 속성을 가지고 있지 않기 때문에, 살인 표현으로 말할 수는 없다. 타임 스탬프, 소유자 등 - 그러나,보다 정교한 시스템이 프로세스를 통해 더 많은 정보를 연결합니다. 그것이 목록 * procs가 *에 보관되지 않기 때문에 기본 과정이 살해 할 수 없습니다.
;21.3 이하보다 신속한 프로토 타입


;continuations와 시뮬레이션 프로세스는 실제 운영 체제 프로세스만큼 효율적이 될 수 없습니다. 이 장에서에있는 것과 같은 프로그램으로, 다음, 사용 뭐야?

;이러한 프로그램은 스케치가하는 것과 같은 방법으로 유용하다. 답사의 프로그래밍이나 빠른 프로토 타이핑에 프로그램이 너무 자신의 아이디어를 작업을위한 수단으로서 그 자체가 끝이 아니다. 다른 많은 분야에서이 기능을 담당하고 무언가 스케치라고합니다. 건축가는 원칙적으로 자신의 머리에 전체 건물을 설계할 수 있습니다. 그러나 대부분의 건축가들은 손에 연필과 함께 더 나은 생각하는 것 : 건물의 설계는 일반적으로 예비 스케치 시리즈에 근무하고 있습니다.

;래피드 프로토 타이핑 소프트웨어를 스케치한다. 건축가 최초의 스케치와 마찬가지로 소프트웨어 프로토 타입은 몇 연소 스트로크로 그려지지하는 경향이있다. 비용과 효율성의 고려 사항은 전체에 아이디어를 개발하기 위해 초기 푸쉬에서 무시됩니다. 그 결과,이 단계에서, unbuildable 건물이나 소프트웨어의 길을 비효율적인 부분이 될 가능성이 높습니다. 하지만, 스케치, 왜냐하면 모두 동일한 가치

;그들은 간단히 정보를 전달.
;그들은 실험 기회를 제공합니다.
;이 장에서 설명하는 프로그램은 성공하는 챕터에서 이들처럼 스케치입니다. 그것은 몇 가지, 폭넓은 스트로크의 멀티 프로세싱의 윤곽선을 제안합니다. 그리고 생산 소프트웨어에 사용할 정도로 효율적 아니 겠지만, 그것은 스케줄링 알고리즘과 같은 여러 프로세스의 다른 측면을 실험 하기엔 상당히 유용할 수 있습니다.

;챕터 22 - continuations 24 현재 다른 애플리케이션. 그들 중 누구도 제작 소프트웨어에서 사용하기에 충분한 효율적 없습니다. 그 문제, 목록의 재산 목록, 키워드 매개 변수와 같은 비효율적이지만 편리 기능 : LISP 및 신속한 프로토 타입이 함께 진화하기 때문에, LISP 구체적으로 프로토 타입을위한 기능이 많이 포함되어 있습니다. Continuations 아마이 범주에 속합니다. 그들은 프로그램이 필요할 가능성이보다 상태를 저장합니다. 그래서 프롤로그 우리의 지속 기반의 구현은, 예를 들어, 언어를 이해하는 좋은 방법이지만 그것을 구현하는 비효율적인 방법입니다.

;이 책은 하나가 효율성 문제를보다 LISP를 구축할 수 추상적인 관념의 종류에 더 관심있다. 그것은 LISP는 프로토 타입을 쓰기위한 제작 소프트웨어뿐만 아니라 언어를 쓰는 언어임을,하지만 실현하는 것이 중요합니다. LISP는 속도 저하에 대한 명성을 가지고있다면, 그것은 대체로 많은 프로그래머들은 프로토 타입과 함께 중지 때문입니다. 그것은 LISP의 빠른 프로그램을 작성하기 쉽다. 불행히도, 그것은 느린 것들을 작성하는 것은 매우 쉽습니다. 작고 투명하며 매우 고가 : LISP 프로그램의 초기 버전은 다이아몬드처럼 될 수 있습니다. 그렇게 떠날 수있는 좋은 유혹이있을 수 있습니다.

;다른 언어에서는 일단 프로그램이 작동하도록지고의 힘든 작업에 성공, 이미 acceptably 효율있을 수 있습니다. 당신 타일 타일 미리보기 이미지의 크기와 바닥면 많은 낭비하지 말자. 이 원칙에 소프트웨어를 개발하는 데 누군가는 그것이 어려운 프로그램이 작동하면, 그것이 완료되었는지 아이디어를 극복하기 위해 찾을 수 있습니다. "LISP에서는 전혀없이 시간에 프로그램을 작성할 수있다"고, 생각할 수 있습니다 "하지만 소년, 그들은 천천히합니다." 사실, 두 사건이다. 당신이 빠른 프로그램을 얻을 수 있지만, 그들을 위해 일을해야합니다. 이러한 측면에서 LISP를 사용하면 대신 가난한 하나의 풍부한 나라에 살고있는 것 같습니다 그것은 하나가이 살아남기 위해 노력보다 낫다 반드시 얇게 유지하기 위해 노력한다,하지만 불행한 것, 그리고의 문제로 얇은되고 있습니다 물론 이죠.

;덜 추상적인 언어에서는 기능이 작동합니다. LISP에서는 속도를 위해 작동합니다. 다행히 속도에서 근무하는 것은 쉽습니다 : 대부분의 프로그램은 단 몇 임계 섹션에 속도 문제 있습니다.